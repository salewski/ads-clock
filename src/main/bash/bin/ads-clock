#!/bin/bash -

# Copyright (c) 2016 Alan D. Salewski <salewski@att.net>
#
#     This program is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program; if not, write to the Free Software Foundation,
#     Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301,, USA.

# ads-clock: FIXME: document script
#

declare -r PROG='ads-clock'


# FIXME: one day this will be filtered in at build time
declare -r MAINTAINER='Alan D. Salewski <salewski@att.net>'

# FIXME: one day this will be filtered in at build time
declare -r VERSION='0.0.1'

# FIXME: one day this will be filtered in at build time
# This variable is replaced at build time
# declare -r gl_const_build_date='@BUILD_DATE@'
# declare -r gl_const_release="${VERSION}  (built: ${gl_const_build_date})"
declare -r gl_const_release="${VERSION}"

BE_VERBOSE=false


declare -a F_CLEANUP_HOOK_NAMES=()

function f_add_cleanup_hook_name () {
    F_CLEANUP_HOOK_NAMES+=( $1 );
}


function f_cleanup () {

    if test ${#F_CLEANUP_HOOK_NAMES[@]} -eq 0; then
        # No cleanup hooks, so nothing to do
        return
    fi

    local cleanup_hook
    local idx

    let idx=${#F_CLEANUP_HOOK_NAMES[@]}-1

    # Note that we're running the cleanup hooks in opposite order from which
    # they were installed.
    #
    while test $idx -ge 0; do

        cleanup_hook=${F_CLEANUP_HOOK_NAMES[$idx]}

        if $BE_VERBOSE; then
            printf "${PROG} (info): running cleanup hook: [%s]\n" "${cleanup_hook}" 1>&2
        fi

        test -n "$cleanup_hook" && eval "$cleanup_hook"

        let idx=$idx-1
    done
}

function f_cleanup_and_die () {
    f_cleanup
    exit 1
}

trap 'printf "$PROG (warn): HUP signal caught; bailing out\n"  1>&2; f_cleanup_and_die' HUP
trap 'printf "$PROG (warn): INT signal caught; bailing out\n"  1>&2; f_cleanup_and_die' INT
trap 'printf "$PROG (warn): QUIT signal caught; bailing out\n" 1>&2; f_cleanup_and_die' QUIT
trap 'printf "$PROG (warn): TERM signal caught; bailing out\n" 1>&2; f_cleanup_and_die' TERM

trap 'f_cleanup' EXIT



f_print_help () {

    cat <<EOF
usage: $PROG [OPTION...]
Use your terminal as a clock.

  -h, --help     Print this help message on stdout
  -V, --version  Print the version of the program on stdout
  -v, --verbose  Tell what is being done. Two or more -v options turns on tracing (set -x)
      --         Signals the end of options and disables further options processing.

Report bugs to $MAINTAINER.
EOF
}

f_print_version () {
    cat <<EOF
${PROG} ${gl_const_release}
Copyright (C) 2016 Alan D. Salewski
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Alan D. Salewski.
EOF
}


while test $# -gt 0 ; do

    option=$(expr "x$1" : 'x\(--[^=]*\)' \| \
                  "x$1" : 'x\(-.\)'      \| \
                  "x$1" : 'x\(.*\)')

    optarg=$(expr "x$1" : 'x--[^=]*=\(.*\)' \| \
                  "x$1" : 'x-.\(.*\)')

    case $1 in

        --help | -h )
            # print help message
            f_print_help
            exit 0
            ;;

        --version | -V )
            # print program version info
            f_print_version
            exit 0
            ;;

        --verbose | -v )
            # Accumulating 'verbose' opt. A single -v opt simply turns
            # BE_VERBOSE on; two or more '-v' opts turns tracing on. Note that
            # if you intend to turn tracing on, you'll probably want your -v
            # opts to be the first opts on the command line (so they take
            # effect earlier).
            if $BE_VERBOSE; then
                # We've seen at least one -v opt before, so now we're turning tracing on
                set -x
            else
                # First -v opt we're seeing
                BE_VERBOSE=true
            fi
            shift
            ;;

        -- ) # Stop option processing
            shift
            break
            ;;

        --* | -* )
            # Unrecognized option
            printf "${PROG} (error): unrecognized option \`%s'\n" "$option" 1>&2
            f_print_help 1>&2
            exit 1
            ;;

        * ) # Unrecognized non-option

            # We'll treat the first non-option and all remaining arguments as
            # names of files to process; note that we DO NOT shift off the
            # first, but merely stop processing command line options when we
            # see it.
            break
            ;;
    esac
done

# FIXME: exit with error if we encounter any unexpected command line arguments


# # All remaining arguments are interpretted as the names of files to process.
# #
# while test $# -gt 0 ; do

#     _one_file_path=$1; shift

#     # do something with ${_one_file_path}
# done


#     $ watch -n 1 '(dt=$(date --rfc-3339=seconds); for fnt in slant shadow small smscript; do echo "$dt" | figlet -t -c -W -f "$fnt"; done)'
#
#     $ watch -n 1 '(dt=$(date --rfc-3339=seconds); for nn in $(seq 1 30); do echo; done; echo "$dt" | figlet -t -c -W )'

# CSI = "Control Sequence Introducer" (or maybe "Control Sequence Initiator"); see notes above.
export CSI='\033['

export COLOR_OFF="${CSI}0m"

# 16 colors available on all color consoles ("normal" and "bright" variations)
#
export COLOR_BRIGHT_WHITE="${CSI}1;37m"
export COLOR_WHITE="${CSI}0;37m"

export COLOR_GRAY="${CSI}1;30m"
export COLOR_BLACK="${CSI}0;30m"

export COLOR_RED="${CSI}0;31m"
export COLOR_BRIGHT_RED="${CSI}1;31m"

export COLOR_GREEN="${CSI}0;32m"
export COLOR_BRIGHT_GREEN="${CSI}1;32m"

export COLOR_YELLOW="${CSI}0;33m"
export COLOR_BRIGHT_YELLOW="${CSI}1;33m"

export COLOR_BLUE="${CSI}0;34m"
export COLOR_BRIGHT_BLUE="${CSI}1;34m"

export COLOR_MAGENTA="${CSI}0;35m"
export COLOR_BRIGHT_MAGENTA="${CSI}1;35m"
export COLOR_CYAN="${CSI}0;36m"
export COLOR_BRIGHT_CYAN="${CSI}1;36m"

# $ (dt=$(date --rfc-3339=seconds); for nn in $(seq 1 30); do echo; done; echo "$dt" | toilet -f term -t -W -f bigmono12)

# NOTE: interval unit is seconds
watch --interval 1 \
      --no-title   \
      --color      \
      ads-clock-once
