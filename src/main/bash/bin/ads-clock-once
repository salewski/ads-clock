#!/bin/bash -

# Copyright (c) 2016 Alan D. Salewski <salewski@att.net>
#
#     This program is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program; if not, write to the Free Software Foundation,
#     Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301,, USA.

# ads-clock-once: FIXME: document script
#

declare -r PROG='ads-clock-once'


# FIXME: one day this will be filtered in at build time
declare -r MAINTAINER='Alan D. Salewski <salewski@att.net>'

# FIXME: one day this will be filtered in at build time
declare -r VERSION='0.0.1'

# FIXME: one day this will be filtered in at build time
# This variable is replaced at build time
# declare -r gl_const_build_date='@BUILD_DATE@'
# declare -r gl_const_release="${VERSION}  (built: ${gl_const_build_date})"
declare -r gl_const_release="${VERSION}"

BE_VERBOSE=false


declare -a F_CLEANUP_HOOK_NAMES=()

function f_add_cleanup_hook_name () {
    F_CLEANUP_HOOK_NAMES+=( $1 );
}


function f_cleanup () {

    if test ${#F_CLEANUP_HOOK_NAMES[@]} -eq 0; then
        # No cleanup hooks, so nothing to do
        return
    fi

    local cleanup_hook
    local idx

    let idx=${#F_CLEANUP_HOOK_NAMES[@]}-1

    # Note that we're running the cleanup hooks in opposite order from which
    # they were installed.
    #
    while test $idx -ge 0; do

        cleanup_hook=${F_CLEANUP_HOOK_NAMES[$idx]}

        if $BE_VERBOSE; then
            printf "${PROG} (info): running cleanup hook: [%s]\n" "${cleanup_hook}" 1>&2
        fi

        test -n "$cleanup_hook" && eval "$cleanup_hook"

        let idx=$idx-1
    done
}

function f_cleanup_and_die () {
    f_cleanup
    exit 1
}

trap 'printf "$PROG (warn): HUP signal caught; bailing out\n"  1>&2; f_cleanup_and_die' HUP
trap 'printf "$PROG (warn): INT signal caught; bailing out\n"  1>&2; f_cleanup_and_die' INT
trap 'printf "$PROG (warn): QUIT signal caught; bailing out\n" 1>&2; f_cleanup_and_die' QUIT
trap 'printf "$PROG (warn): TERM signal caught; bailing out\n" 1>&2; f_cleanup_and_die' TERM

trap 'f_cleanup' EXIT



f_print_help () {

    cat <<EOF
usage: $PROG [OPTION...]
Prints one clock tick on stdout; intended to be invoked from ads-clock(1)

  -h, --help     Print this help message on stdout
  -V, --version  Print the version of the program on stdout
  -v, --verbose  Tell what is being done. Two or more -v options turns on tracing (set -x)
      --         Signals the end of options and disables further options processing

Report bugs to $MAINTAINER.
EOF
}

f_print_version () {
    cat <<EOF
${PROG} ${gl_const_release}
Copyright (C) 2016 Alan D. Salewski
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Alan D. Salewski.
EOF
}


while test $# -gt 0 ; do

    option=$(expr "x$1" : 'x\(--[^=]*\)' \| \
                  "x$1" : 'x\(-.\)'      \| \
                  "x$1" : 'x\(.*\)')

    optarg=$(expr "x$1" : 'x--[^=]*=\(.*\)' \| \
                  "x$1" : 'x-.\(.*\)')

    case $1 in

        --help | -h )
            # print help message
            f_print_help
            exit 0
            ;;

        --version | -V )
            # print program version info
            f_print_version
            exit 0
            ;;

        --verbose | -v )
            # Accumulating 'verbose' opt. A single -v opt simply turns
            # BE_VERBOSE on; two or more '-v' opts turns tracing on. Note that
            # if you intend to turn tracing on, you'll probably want your -v
            # opts to be the first opts on the command line (so they take
            # effect earlier).
            if $BE_VERBOSE; then
                # We've seen at least one -v opt before, so now we're turning tracing on
                set -x
            else
                # First -v opt we're seeing
                BE_VERBOSE=true
            fi
            shift
            ;;

        -- ) # Stop option processing
            shift
            break
            ;;

        --* | -* )
            # Unrecognized option
            printf "${PROG} (error): unrecognized option \`%s'\n" "$option" 1>&2
            f_print_help 1>&2
            exit 1
            ;;

        * ) # Unrecognized non-option

            # We'll treat the first non-option and all remaining arguments as
            # names of files to process; note that we DO NOT shift off the
            # first, but merely stop processing command line options when we
            # see it.
            break
            ;;
    esac
done

# FIXME: exit with error if we encounter any unexpected command line arguments


# # All remaining arguments are interpretted as the names of files to process.
# #
# while test $# -gt 0 ; do

#     _one_file_path=$1; shift

#     # do something with ${_one_file_path}
# done


#     $ watch -n 1 '(dt=$(date --rfc-3339=seconds); for fnt in slant shadow small smscript; do echo "$dt" | figlet -t -c -W -f "$fnt"; done)'
#
#     $ watch -n 1 '(dt=$(date --rfc-3339=seconds); for nn in $(seq 1 30); do echo; done; echo "$dt" | figlet -t -c -W )'

# CSI = "Control Sequence Introducer" (or maybe "Control Sequence Initiator"); see notes above.
export CSI='\033['

export COLOR_OFF="${CSI}0m"

# 16 colors available on all color consoles ("normal" and "bright" variations)
#
export COLOR_BRIGHT_WHITE="${CSI}1;37m"
export COLOR_WHITE="${CSI}0;37m"

export COLOR_GRAY="${CSI}1;30m"
export COLOR_BLACK="${CSI}0;30m"

export COLOR_RED="${CSI}0;31m"
export COLOR_BRIGHT_RED="${CSI}1;31m"

export COLOR_GREEN="${CSI}0;32m"
export COLOR_BRIGHT_GREEN="${CSI}1;32m"

export COLOR_YELLOW="${CSI}0;33m"
export COLOR_BRIGHT_YELLOW="${CSI}1;33m"

export COLOR_BLUE="${CSI}0;34m"
export COLOR_BRIGHT_BLUE="${CSI}1;34m"

export COLOR_MAGENTA="${CSI}0;35m"
export COLOR_BRIGHT_MAGENTA="${CSI}1;35m"
export COLOR_CYAN="${CSI}0;36m"
export COLOR_BRIGHT_CYAN="${CSI}1;36m"

t_cols=$(tput cols)
if test $? -ne 0; then
    printf "${PROG} (error): was unable to determine number of available terminal columns; bailing out\n" 1>&2
    exit 1
fi

t_rows=$(tput lines)
if test $? -ne 0; then
    printf "${PROG} (error): was unable to determine number of available terminal lines; bailing out\n" 1>&2
    exit 1
fi

TOILET_PROG='toilet'

declare -a MY_TOILET_OPTS=()

MY_TOILET_OPTS+=( '--width'   )
MY_TOILET_OPTS+=( "${t_cols}" )

MY_TOILET_OPTS+=( '-W' )  # render characters at their full width

MY_TOILET_OPTS+=( '-f' )
MY_TOILET_OPTS+=( 'bigmono12' )  # XXX: maybe make this user-configurable


yyyymmdd="$(   date "+%Y-%m-%d " | "${TOILET_PROG}" "${MY_TOILET_OPTS[@]}")"
hhmmss="$(     date "+%H:%M:%S"  | "${TOILET_PROG}" "${MY_TOILET_OPTS[@]}")"
utc_offset="$( date "+%:z"       | "${TOILET_PROG}" "${MY_TOILET_OPTS[@]}")"


IFS_hold=$IFS
IFS=
declare -a date_lines=()
while read -r one_date_line; do
    date_lines+=( "${one_date_line}" )
done <<< "${yyyymmdd}"
unset yyyymmdd

declare -a time_lines=()
while read -r one_time_line; do
    time_lines+=( "${one_time_line}" )
done <<< "${hhmmss}"
unset hhmmss

declare -a utc_offset_lines=()
while read -r one_utc_offset_line; do
    utc_offset_lines+=( "${one_utc_offset_line}" )
done <<< "${utc_offset}"
unset utc_offset

# All data chunks will span the same number of lines, but some lines may be
# (slightly) longer than others.
#
width_longest_line=0

IFS=$IFS_hold

declare -a combined_lines=()
for t_idx in "${!date_lines[@]}"; do

    t_one_date_line="${date_lines[$t_idx]}"
    t_one_time_line="${time_lines[$t_idx]}"
    t_one_utc_offset_line="${utc_offset_lines[$t_idx]}"

    # Note that we're capturing the line width /before/ we add in the escape
    # sequences; we are interested in the width of the printable characters
    # only.
    #
    t_width_this_line=$(( ${#t_one_date_line} + ${#t_one_time_line} + ${#t_one_utc_offset_line} ))
    if (( $t_width_this_line > $width_longest_line)); then
        width_longest_line=${t_width_this_line}
    fi

    combined_lines+=( "${date_lines[$t_idx]}${COLOR_CYAN}${time_lines[$t_idx]}${COLOR_OFF}${utc_offset_lines[$t_idx]}" )
done

height_in_rows_of_data=${#combined_lines[@]}

row_start=$(( ( ${t_rows} - ${height_in_rows_of_data} ) / 2 ))

col_start=$(( ( ${t_cols} - ${width_longest_line} ) / 2 ))

left_pad_spaces=''
for nn in $(seq 1 $col_start); do
    left_pad_spaces="${left_pad_spaces} "
done

# This will be stripped from the output when running via watch(1) (our primary
# use case), but is nice to have here, too, for nicer output when invoking
# directly.
#
tput clear
if test $? -ne 0; then
    printf "${PROG} (error): was unable to clear terminal; bailing out\n" 1>&2
    exit 1
fi

# We do not attempt to drive cursor position via tput(1) here because it will
# not work when running under watch(1) -- non-printing control sequences will
# never make it to the terminal because they are stripped out. Instead, we'll
# just emit newline characters below until we get to the starting line.
#
# tput cup $(( ${row_start} - 1 )) 0
# if test $? -ne 0; then
#     printf "${PROG} (error): was unable to position cursor on starting output row; bailing out\n" 1>&2
#     exit 1
# fi
for nn in $(seq 1 $row_start); do
    echo
done

for t_one_line in "${combined_lines[@]}"; do

    echo -e "${left_pad_spaces}${t_one_line}"
done
